# 코드에서 나는 악취

<br>

## 들어가면서
리팩터링을 방법들을 적용하는 능력과 이를 제때 적용하는 능력은 다르다. 24가지의 코드의 악취가 나는 상황을 설명해 주었고, 각각의 상황에 대해 어떻게 대처해야하는지 리팩터링 기법을 소개해주었다. 새로 배운 부분도 있고, 기존에 알고 있던 부분들은 다시 한번 점검할 수 있었다. 반면 아직 이해가 부족한 부분은 일단 생략해 두었다. 추후 업데이트할 예정이다.

<br>

## 리팩터링의 징후

1. 기이한 이름  
_**코드를 명료하게 표현하는데 가장 중요한 요소 하나는 '이름'이다.**_ 함수, 모듈, 변수, 클래스 등은 이름만 보고도 무슨 일을 하고 어떻게 사용하는지 명확히 알도록 이름을 지어야 한다. 이름을 잘 지으면 그 만큼 문맥을 파악하는데 시간을 아낄 수 있다. 이름 짓는 것은 프로그래밍에서 어려운 걸로 손꼽히지만 마땅한 이름이 도저히 떠오르지 않는다면 설계에 문제가 있는지 살펴봐야한다.

2. 중복 코드  
코드가 중복되면 가각을 볼 때마다 서로 차이점은 없는지 확인해야하는 부담이 생기고, 수정하면 다른 비슷한 코드들도 모두 살펴보고 적절히 수정해야한다.

3. 긴 함수  
_**함수가 길수록 코드를 이해하기가 어렵다.**_ 물론 함수가 짧으면 왔다갔다하면서 코드를 읽어야하는 부담은 있지만 짧은 함수의 이름을 잘 지어두면 본문을 읽지않고도 코드의 흐름을 이해하기 쉬워진다. 함수 이름을 지을 때 동작방식이 아닌 '의도'가 드러나게 짓는다. 즉 '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리하다. 함수를 짧게 만드는 작업의 99%는 **함수 추출하기**가 차지한다. 함수가 매개변수와 임시 변수를 많이 사용하면 추출 작업에 방해가 된다. 이때는 **임시 변수를 질의 함수로 바꾸기**로 임시 변수의 수를, **매개변수 객체 만들기**와 **객체 통째로 넘기기**로는 매개변수의 수를 줄일 수 있다. 그래도 임시변수와 매개변수가 많다면 *함수를 명령으로 바꾸기*를 고려한다.
추출할 코드 덩어리를 찾는 경우는 주석, 조건문, 반복문 등이 추출 대상의 실마리를 제공한다. 주석은 코드만으로는 목적을 이해하기 어려운 부분에 달려있는 경우가 많다. 조건문은 **조건문 분해하기**로 대응한다. switch문을 구성하는 case의 본문을 **함수 추출하기**를 적용해서 함수 호출문 하나로 바꾼다. 반복문은 그 자체를 빼내 독립된 함수로 만든다. 이 때 반복문에 두 가지 작업이 섞여있으면 **반복문 쪼개기**를 통해 작업을 분리한다. 오래 잘 활용되는 프로그램들은 짧은 함수로 구성된 경우가 많다. 짧은 코드는 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점이 있다.

4. 긴 매개변수 목록  
여러개의 매개변수가 있는 것을 발견하면 아래 방법들을 적용해보자.
    - **매개 변수를 질의 함수로 바꾸기**
    - **객체 통째로 넘기기**
    - **매개변수 객체 만들기**
    - **플래그 인수 제거하기**
    - **여러 함수를 클래스로 묶기**  
  
5. 전역 데이터  
프로그래머라면 전역 데이터를 조심하라고 들어왔을 것이다. _**전역 데이터는 코드베이스 어디서든 접근할 수 있고 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제다. 그래서 버그는 발생하는데 원인을 찾아내기 어렵다.**_ 전역변수 뿐만 아니라 클래스 변수와 싱글톤에서도 같은 문제가 발생한다.  
이를 해결하는 리팩터링은 **변수 캡슐화하기**다. 다른 코드에서 변수를 건드릴 가능성이 있다면 이것부터 적용한다. 이런 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다. 더 나아가 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근범위를 최소로 줄이는 것도 좋다. 전역 변수가 몇개 뿐이라면 감당할 수 있겠지만, 많다면 관리가 굉장히어렵다. 따라서 전역 변수는 캡슐화하는 편이 좋다.


6. 가변 데이터  
원본 데이터를 변경할 경우, 코드 어딘가에서는 기대한 값이 달라져 버그가 발생할 수 있다. 특히 원인을 알아내기가 매우 어렵다. 함수형 프로그래밍에서 데이터를 변경하려면 복사본을 만들어서 반환하는 불변성의 원칙이 생긴 이유다. 함수형 프로그래밍이 아니라고 해도 무분별한 데이터 수정에 따른 위험을 줄이는 방법은 존재한다. 
    -  **변수 캡슐화기**를 적용해 정해놓은 함수를 거쳐야만 값을 수정하도록 만들어 코드를 감시하기 쉽게 만든다. 
    -  **변수 쪼개기**를 이용해 용도별로 독립 변수에 저장하여 값 갱신이 문제를 일으킬 여지를 없앤다. 이때 갱신 로직은 **문장 슬라이드하기**와 **함수 추출하기**를 이용해 코드를 분리하는 것이 좋다.
    -  API를 만들 때는 **질의 함수와 변경 함수 분리하기**를 활용해서 필요한 경우가 아니면 부작용이 있는 코드를 호출할 수 없게 한다.가능한한 **세터 제거하기**도 적용한다. 간혹 세터를 호출하는 클라이언트를 찾는 것만으로도 변수의 유효범위를 줄이는 데 도움이 된다.
    -  값을 다른 곳에서 설정할 수 있는 가변 데이터의 악취는 고약하다. **파생 변수를 질의 함수로 바꾸기**를 적용해준다.
    -  **여러 함수를 클래스로 묶기**, **여러 함수를 변환 함수로 묶기**를 활용해서 변수를 갱신하는 코드들의 유효범위를 제한한다. 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면, 일반적으로 **참조를 값으로 바꾸기**를 적용하여, 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하는 편이 낫다.  

7. 뒤엉킨 변경  
_**뒤엉킨 변경이란 코드를 수정할 때 단 한곳을 찾아 수정해야 하는데 그렇지 못하고 여러곳을 수정해야 하는 것이다.**_ 이는 단일 책임 원칙이 제대로 지켜지지 않았을 때 나타난다. 단일 책임 원칙이란 하나의 모듈은 변경의 이유가 하나여야 한다는 원칙이다. 지켜지지 않을 경우 모듈은 여러 이유로 다양한 방식으로 변경되는 상황이 발생한다. 이 때 뒤엉킨 변경이 발생할 확률이 높다. 예를 들어 데이터베이스가 추가 될때마다 바꿔야할 함수 세 개를 바꿔야하고, 금융 상품이 추가될 때마다 또 다른 함수 네 개를 바꿔야하는 모듈이 있다면 뒤엉킨 변경이 발생했다는 뜻이다. 데이터베이스 연동과 금융 상품 처리는 서로 다른 맥락에서 이뤄지므로 독립된 모듈로 분리해야 편하다. 그래야 무언가를 수정할 때 해당 맥락만 이해해도 작업할 수 있다. 앞선 예시처럼 데이터베이스에서 데이터를 가져와 금융 상품 로직에서 처리되는게 자연스러운 맥락이라면 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하는 식으로 단계를 분리한다.(*단계쪼개기*). 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, 각 맥락에 해당하는 모듈을 만들어서 관련 함수들을 모아 처리과정을 맥락별로 구분한다.(*함수 옮기기*) 이 때 여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전에 **함수 추출하기**부터 진행한다.
8. 산탄총 수술  
코드를 수정해야할 때, 수정할 클래스나 함수가 여러개이고 코드 전반에 퍼져 있는 경우를 말한다. 이는 실수를 범할 리스크가 커진다. 이 경우 변경되는 대상들을 **함수 옮기기**와 **필드 옮기기**를 통해 한 모듈에 묶어주어야 한다. 비슷한 데이터를 다루는 함수가 많다면 **여러 함수를 클래스로 묶기**를 적용한다. 이렇게 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 **단계 쪼개기**를 적용한다. 어설프게 분리된 로직은 **함수 인라인하기**나 **클래 인라인하기** 같은 인라인 리팩터링으로 하나로 합치는 것도 산탄총 수술에 대처하는 좋은 방법이다. 메서드나 클래스가 비대해지지만 코드를 재구성하는 중간 과정에서는 큰 덩어리로 뭉쳐지는 것은 걱정하지 않아도 된다. 나중에 더 좋은 구조로 분리할 수 있게 만들어주기 때문이다.

9. 기능 편애  
기능 편애는 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상화작영할 일이 더 많은 것이다. _**프로그램을 모듈화 할 때 바람직한 것은 모듈 내부에서 상호작용을 최대로 늘리고, 모듈과 모듈 사이의 상호작용은 최소로 낮추는 것이다.**_ 해결 방법은 쉽다. **함수 추출하기**를 통해 원하는 모듈로 보내준다. 물론 각 모듈에서 엇비슷하게 사용되는 애매한 경우도 있다. 이럴 땐 더 많이 사용되는 모듈에 옮기거나 **함수 추출하기**로 여러 코드 조각을 만들어 각각을 적절한 모듈로 옮기면 된다.

10. 데이터 뭉치  
필드 형태의 뭉처다니는 데이터들은 **클래스 추출하기**로 하나의 객체로 묶는다. 다음 메서드 시그니처에 있는 데이터 뭉치들은 **매개변수 객체 만들기**나 **객체 통째로 넘기기**를 적용해서 매개변수 수를 줄여본다. 데이터 뭉치인지 판별하려면 값 하나를 삭제하고 나머지 데이터만으로는 의미가 없는지 판단하면 된다. 기능 편애를 없애는 과정에서 새로운 클래스를 만들었다면 이어서 그 클래스로 옮기면 좋을 동작은 없는지 살펴보자.

11. 기본형 집착  
(생략)

12. 반복되는 switch문  
중복된 switch에 조건절을 하나 추가할 떄마다 모두 찾아서 조건을 추가해주어야 한다. 이때 **조건부 로직을 다형성**으로 작성해주면 된다.

13. 반복문  
반복문은 프로그래밍의 핵심요소인 시대는 지났다. **반복문을 파이프라인으로 바꾸기**를 적용해서 반복문을 제거할 수 있다.

14. 성의 없는 요소  
본문을 그대로 쓰는 것과 다를바 없는 함수, 메서드가 하나뿐인 클래스등 성의없는 역할을 하는 것들은 제거하는 것이 좋다. 이는 리팩터링을 거치면서 그 역할이 줄었을 수도 있고, 원래 추가할 계획이었지만 그렇지 않았을 수도 있다. 이런 경우엔 **함수 인라인하기**나 **클래스 인라인하기**로 처리한다. 상속을 사용했다면 **계층합치기**를 적용한다.

15. 추측성 일반화  
당장 걸리적거리는 코드는 치우자. 미래를 대비해 작성한 부분은 사용하면 다행이지만 그렇지 않으면 낭비다.

16. 임시 필드  
특정 상황에만 값이 설정되는 필드를 가진 클래스도 있다. 하지만 객체를 가져올 때는 당연히 모든 필드가 채워져있을거라 예상하기 때문에 임시 필드를 갖도록 클래스를 만들어두면 코드를 파악하기가 어렵다. 이런 경우엔 **클래스 추출**하기를 통해 새 클래스를 만든다음 **함수 옮기기**를 통해 임시필드와 관련된 코드를 모조리 새 클래스에 옮겨준다. 만약 임시 필드들이 유효한지 확인한 후 동작하는 조건부 로직이 있다면 **특이 케이스 추가하기**로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어서 제거할 수 있다.

17. 메시지 체인  
(생략)
18. 중개자  
(생략)


19. 내부자 거래  
모둘 사이의 데이터 거래를 최소로 줄이고 모두 투명하게 처리해야한다. **함수 옮기기**와 **필드 옮기기** 기법으로 떼어놓아서 사적으로 처리하는 부분을 줄인다. 여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 제3의 모듈을 만들거나 **위임 숨기기**를 이용하여 다른 모듈이 중간자 역할을 하게 만든다. 상속 구조에서 자식 클래스를 분리해야할 때는 **서브클래스를 위임으로 바꾸기**나 **슈퍼클래스를 위임으로 바꾸기**를 활용하자.

20. 거대한 클래스  
한 클래스가 너무 많은 일을 하면 필드수도 늘어나고 중복도 일어나기 쉽다. 이럴 때는 클래스 추출하기로 필드들 일부를 따로 묶는다. 일반적으로는 접두어나 접미어가 같은 필드들이 추출될 후보들이다. 분리할 컴포넌트를 원래 클래스와 상속 관계로 만드는게 좋다면 **슈퍼클래스 추출하기**나 **타입 코드를 서브클래스로 바꾸기**를 적용하는 편이 더 쉽다. 또는 기능 그룹이 개별 클래스로 추출될 후보다. **클래스 추출하기** **슈퍼클래스 추출하기**나 **타입 코드를 서브클래스로 바꾸기**등을 활용해서 여러 클래스로 분리한다.

21. 서로 다른 인터페이스의 대안 클래스들  
(생략)
22. 데이터 클래스  
(생략)
23. 상속 포기  
(생략)
24. 주석  
주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요없는 코드로 리팩터링해본다. 주석은 악취가 아닌 향기를 코드에 입힌다. 이로 하여금 코드를 더 이해하기 쉽게 만들어 준다. 하지만 이는 코드를 잘못 작성했기 때문인 경우가 많다. 특정 코드 블록이 하는 일에 주석을 남기고 싶다면 **함수 추출하기**를 적용해본다. 이미 추출되어 있는 함수임에도 여전히 설명이 필요하면 **함수 선언 바꾸기**로 함수 이름을 바꿔본다. 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 **어서션 추가하기**가 대기하고 있다.

<br>

## 마무리
항상 코드를 나눌 때는 적당히 나눠왔던거 같다. "관련된 코드가 어느 정도 한 곳에 모여있는게 코드 읽기 더 편해" 혹은 "함수를 이렇게 까지 나누는 것은 정신없는거 같아" 하면서... 이는 순전히 코드를 작성한 당사자인 내 입장이다. 남들이 볼 때 함수나 클래스로 코드가 묶여있지 않고 그냥 하드코딩으로 작성되어있을 때, 남들은 그 코드의 맥락을 파악하기 위해선 세부적으로 읽어야 한다. 반면 퍼져있는 코드들을 함수나 클래스로 묶었을 때는 함수나 클래스의 이름들을 통해 전체 맥락뿐아니라 각각의 역할을 파악할 수 있다. 즉 함수를 추출하는 것은 단지 구조만 잡는게 아니라 그 덩어리들을 설명하는 과정인 것이다. 물론 기준 없이 무조건 나누는 것만이 정답은 아니지만 함수를 나눌 때 어떤 점이 좋은지 느낀바를 적어보려한다.  
&nbsp;&nbsp;이전까지 함수를 추출하는 작업이 주는 이점이 정확히 무엇인지 모르고 사용해왔다. _**함수를 추출하는 작업이 주는 효과는 코드를 구조적으로 분리하는 것과 동시에 각 코드덩어리를 설명할 기회를 얻는다.**_ 다시 말해서 거대한 코드 덩어리를 여러개의 덩어리로 나눌 때, 우리는 함수로 긴 코드를 여러개의 덩어리들로 분리할 수 있고 각 함수의 이름을 붙여줄 수 있다. 이 때 함수의 이름은 각각의 코드 덩어리를 설명하는 역할을 한다. 이로써 우리는 긴 코드를 세부적으로 읽지 않고도 함수 이름들을 읽어내려가며 거대한 코드의 역할을 파악할 수 있다. 실제 적용했을 때 코드의 양은 많아졌지만 코드를 파악하기 정말 좋아졌다는 걸 체감했다. 특히 네이밍이 얼마나 중요한지 깨달았다. 아무리 코드를 잘 나누었다 하더라도 함수이름이 이상하면 분리 작업의 효과를 얻지 못한다. 함수의 이름을 고민하는 과정에서 좋았던점은 이 함수가 어떤 역할을 하는지 확실히 파악할 수 있었고 머릿속에 코드가 더 명료하게 정리되는 것이었다. 이 후 함수 추출작업이 끝나면 전체코드를 읽어내려가면서 코드가 자연스럽게 읽히는지 점검했다. 확실히 코드가 매끄러워졌음을 알 수 있었다. 하지만 함수의 이름을 짓기 어려운 경우도 있었는데 이는 내가 분리한 함수가 한가지 역할이 아니라 그 이상을 하고 있기 때문이었다. 이는 함수를 쪼갠 함수를 한번 더 분리하는 과정을 거쳤다.  
&nbsp;&nbsp;리팩터링의 타이밍을 아는 방법은 코드의 악취를 맡을 수 있는 것이다. 코드의 악취는 세부 구현사항 뿐만 아니라 코드의 구조와도 많은 관련이 있음을 알았다. 이 부분을 읽으면서 _**코드를 볼 때 세부 구현사항 뿐만 아니라 코드의 구조를 파악하는 습관도 꼭 필요한 것**_ 이라고 생각하게 되었다. 출발하는 각도가 약간만 달라도 도착지점이 크게 변할 수 있기 때문에 이 부분은 작지만 멀리보면 큰 변화를 주는 부분이다. 프로그래머에게 코드 구조를 보는 습관은 좋은 습관이 아니라 필수 습관이다.
