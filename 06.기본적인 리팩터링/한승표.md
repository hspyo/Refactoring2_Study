# 기본적인 리팩터링

<br>

1. 함수 추출하기  
   역할이 있는 코드 조각을 독립된 함수로 추출하여 목적에 맞는 이름을 지어준다. 이름을 잘 짓는게 중요하다. 나중에 코드를 다시 볼때 함수의 이름만 보고 그 역할을 쉽게 파악할 수 있다. 함수의 역할을 분명히 알면 코드 본문을 신경쓸 일이 거의 없다.  
   &nbsp;함수가 단 한줄이라도 상관없다. 함수를 아주 짧게 분리를 잘하는 것이 우선이다. 심지어 함수의 이름이 본문의 내용보다 길더라도 문제되지 않는다. 코드의 목적이 강조되고 분리가 뚜렷할 때 이점이 더 크다.  
   &nbsp;함수를 짧게 만들면 함수의 호출이 많아져서 성능이 우려될 수 있다. 하지만 오히려 함수가 짧으면 캐싱하기가 더 쉽기 때문에 컴파일러가 최적화하는 데 유리할 때가 많다. M.A. 잭슨에 따르면 성능 최적화의 일반적인 원칙은 첫째 하지마라, 둘째 아직 하지 마라 이다.  
   &nbsp;함수를 추출할 때 명심할 것은 '이름 짓기'와 '변수 다루기'이다.
   함수를 추출하기의 효력을 얻기 위해서는 이름을 잘 지어야한다. '어떻게'가 아닌 '무엇을' 하는지 드러나야한다. 변수를 다루는 것은 크게 2가지 상황이 있다.

   1. 유효범위를 벗어나는 변수가 없을 때  
   2. 유효범위를 벗어나는 변수가 있을 때
      1. 지역 변수를 사용할 때  
      2. 지역 변수를 사용하고 값을 변경할 때

   첫번째 경우에는 함수만 잘 추출하면 별도로 할 일을 없다. 문제는 두번째 경우다. 함수 추출시 유효범위를 벗어나는 변수가 있는 경우 이를 처리해주어야한다. 이때 지역변수를 단순히 사용만하는 경우는 간단하다. 추출한 함수에 매개변수로 전달해주기만 하면된다. 반면 추출한 함수에서 지역 변수를 사용하고 값을 변경하는 경우에 추출한 함수는 변경된 값을 반드시 반환해야한다.

<br>

2. 함수 인라인하기  
   함수 본문이 이름만큼 명확한 경우 불필요하게 추출된 함수를 제거하고 다시 원본함수로 인라인 해준다.

   ```
   function getRating(driver) {
      return moreThanFiveLateDeliveries(driver) ? 2 : 1;
   }
   
   function moreThanFiveLateDeliveries(driver) {
       return driver.numberOfLateDeliveries > 5;
   }
   
   --- 함수 인라인 ---
   
   function getRating(driver) {
     return driver.numberOfLateDeliveries > 5;
   }
   
   ```

<br>

3. 변수 추출하기  
   표현식이 복잡한 경우 지역 변수를 활용해 표현식을 쪼개서 관리하기 쉽게 만들 수 있다. 뿐만아니라 로직의 구성 단계마다 이름을 붙이고 코드의 목적을 명확히 드러낼 수 있다.
   
   ```
     return order.quantity * order.itemPrice - Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 + Math.min(order.quantity * order.itemPrice * 0.1, 100)
   
     --- 변수 추출 ---
   
     const basePrice = order.quantity * order.itemPrice
     const quantityDiscount = Math.max(0, order.quantity - 500) * order.itemPrice * 0.05
     const shipping = Math.min(basePrice * 0.1, 100)
     return basePrice - quantityDiscount + shipping;
   ```

<br>

4. 함수 선언 바꾸기 (함수 이름 바꾸기)  
   함수는 소프트웨어의 시스템 구성 요소들을 연결하는 연결부 역할을 한다. 함수의 이름을 잘 짓는다는 것은 연결부를 잘 정의한다는 것을 의미한다. 연결부가 잘 정의되어야 소프트웨어의 동작을 파악하기 쉬워지고 수정하기도 수월해진다. 잘못된 이름은 혼란을 야기한다. 좋은 이름을 짓기 위해서는 '함수의 목적'을 떠올려보면 좋다. 또한 단번에 적합한 이름을 지으려고하기보다 시간을 두고 적합한 이름이 생각나면 지속적으로 수정해주는 방법이 좋다.

<br>

5. 매개변수 객체 만들기  
   몰려다니는 특정 데이터들은 하나로 묶어주는게 좋다. 데이터 사이의 관계가 명확해지기 때문이다. 이러한 데이터 구조를 묶는 것의 강력한 효과는 코드를 근본적으로 바꿔주는데 있다. 즉 묶여진 데이터 구조를 바탕으로 함수를 추출하고 프로그램을 재구성하는 것이다.

<br>

6. 여러 함수를 변환함수로 묶기  
   변환함수는 원본데이터를 매개변수로 받아서 필요한 데이터를 도출한 뒤, 각각을 출력 데이터의 필드에 넣어 반환한다. '여러 함수를 클래스' 묶기를 사용해도 된다. 원본 데이터가 코드 안에서 갱신될 때는 클래스로 묶는게 사실 더 낫다. 변환 함수로 묶으면 가공 데이터를 새로운 레코드에 저장하므로, 원본 데이터가 수정되면 일관성이 깨질 수 있다. 여러 함수를 한 곳에 묶는 이유는 도출 로직이 중복되는 것을 피하기 위해서다. 함수 추출하기도 동일 효과를 내지만 변환함수나 클래스로 묶는 이유는 찾기 쉽다는데 있다. 함수로 추출하면 추출된지 모르고 지나치거나 동일한 함수를 다시 추출하는 문제가 발생할 수 있다. 즉 데이터 구조와 이를 사용하는 함수가 근처에 있지 않으면 함수를 발견하기 어렵다. 변환 함수 또는 클래스가 이 문제를 해결해준다.

   ```
   function base(aReading) {...}
   function taxableCharge(aReading) {...}
   
   --- 변환 함수 ---
   function enrichReading(argReading) {
     const aReading = _.cloneDeep(argRading);
     aReading.baseCharge = base(aReading);
     aReading.taxableCharge = taxableCharge(aReading);
     return aReading;
   }
   ```

   변환할 레코드를 입력받아서 값을 그대로 반환하는 변환 함수를 만든다. 깊은 복사로 처리하고 원본 데이터가 변경되지 않는지 테스트한다.

<br>

7. 단계 쪼개기    
   단계 쪼개기의 핵심은 이름 그대로 명확하게 단계를 분리하는 것이다. 대상이 되는 코드는 서로 다른 대상을 한꺼번에 다루는 코드이다. 이는 각각의 모듈로 분리해주어야한다. 단순 분리만 하면 되는 것은 아니고 중간데이터 구조를 활용하여 매개변수를 처리하여 각 단계를 유기적으로 연결하는 과정이 필요하다. 예를들어 상품가격을 계산하는 함수가 있다고 하자. 상품가격에는 상품가격과 배송비가 모두 포함되기 때문에 이 함수의 실제 계산 로직은 두 단계로 분리할 수 있다. 이런 경우에 단계 쪼개기를 적용한다. 단계 쪼개기를 할 때 중간 데이터 구조를 활용한다.
